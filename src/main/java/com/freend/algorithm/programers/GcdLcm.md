## 최대공약수와 최소공배수

###### 문제 설명

두 수를 입력받아 두 수의 최대공약수와 최소공배수를 반환하는 함수, solution을 완성해 보세요. 배열의 맨 앞에 최대공약수, 그다음 최소공배수를 넣어 반환하면 됩니다. 예를 들어 두 수 3, 12의 최대공약수는 3, 최소공배수는 12이므로 solution(3, 12)는 [3, 12]를 반환해야 합니다.

##### 제한 사항

- 두 수는 1이상 1000000이하의 자연수입니다.

##### 입출력 예

| n    | m    | return  |
| ---- | ---- | ------- |
| 3    | 12   | [3, 12] |
| 2    | 5    | [1, 10] |

##### 입출력 예 설명

입출력 예 #1
위의 설명과 같습니다.

입출력 예 #2
자연수 2와 5의 최대공약수는 1, 최소공배수는 10이므로 [1, 10]을 리턴해야 합니다.

### 나의 풀이

다음의 방식으로 풀이를 진행했다.

- 우선 최대공약수

- bruteForce
  - 사실 위의 방법도 1, 2번의 튜닝을 거친 것이지만 1차적으론 둘다 나눈 수 중에서 가장 큰 수를 구하면 된다고 생각했다.
  - 저기서는 실행횟수를 줄이기 위해 역으로 실행하고 처음 나온 수에서 멈춰버렸다.
  - [참고사이트](https://opentutorials.org/course/1685/9533)
  - 그러다 참고사이트에서 유크리드 호제법이란 것을 보았다.

- 유클리드 호제법

  - 역시 이런 방법이 있구나 한 생각으로 보게 되었다. 원리는 다음과 같다

  - 큰수에서 작은수를 나눠서 나머지가 0이면 나뉜수가 최대공약수이다.

  - 0이 아니라면 작은수에서 나머지를 다시 나눠서 나머지가 0이면 나뉜수가 최대공약수이다.

  - 0이 아니라면 ~~~

  - 즉 이건 재귀함수까지 해결할 대상이 되었다. 그래서 수식은 다음과 같다

    ```java
    private int getGcd(int minNum, int maxNum) {
        return (maxNum % minNum == 0) ? minNum : getGcd(maxNum % minNum, minNum);
    }
    ```

  - 즉 나눠서 0이면 작은수를 아니면 재귀로 작은수엔 나머지값 큰수엔 작은값을 넣는다.

  - 이래서 최대공약수를 구하면 최소공배수는 쉽다.

- 최대공배수

  - 최대공배수는 그냥 다음과 같다 ```두수의 곱 / 최대공약수``` 